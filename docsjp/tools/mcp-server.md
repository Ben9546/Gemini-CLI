# Gemini CLI での MCP サーバー

このドキュメントでは、Gemini CLI でモデルコンテキストプロトコル (MCP) サーバーを設定および使用するためのガイドを提供します。

## MCP サーバーとは？

MCP サーバーは、モデルコンテキストプロトコルを通じて Gemini CLI にツールとリソースを公開するアプリケーションであり、外部システムやデータソースと対話できるようにします。MCP サーバーは、Gemini モデルとローカル環境または API などの他のサービスとの間のブリッジとして機能します。

MCP サーバーを使用すると、Gemini CLI は次のことができます。

- **ツールの検出:** 標準化されたスキーマ定義を通じて、利用可能なツール、その説明、およびパラメータを一覧表示します。
- **ツールの実行:** 定義された引数で特定のツールを呼び出し、構造化された応答を受信します。
- **リソースへのアクセス:** 特定のリソースからデータを読み取ります (ただし、Gemini CLI は主にツールの実行に重点を置いています)。

MCP サーバーを使用すると、データベース、API、カスタムスクリプト、または特殊なワークフローとの対話など、組み込み機能を超えるアクションを実行するように Gemini CLI の機能を拡張できます。

## コア統合アーキテクチャ

Gemini CLI は、コアパッケージ (`packages/core/src/tools/`) に組み込まれた高度な検出および実行システムを通じて MCP サーバーと統合します。

### 検出レイヤー (`mcp-client.ts`)

検出プロセスは `discoverMcpTools()` によって調整され、次の処理を行います。

1. **設定済みサーバーの反復処理:** `settings.json` の `mcpServers` 設定から設定済みのサーバーを反復処理します。
2. **接続の確立:** 適切なトランスポートメカニズム (Stdio、SSE、またはストリーミング可能な HTTP) を使用して接続を確立します。
3. **ツール定義の取得:** MCP プロトコルを使用して各サーバーからツール定義を取得します。
4. **ツールスキーマのサニタイズと検証:** Gemini API との互換性のためにツールスキーマをサニタイズおよび検証します。
5. **ツールの登録:** 競合解決を使用してグローバルツールレジストリにツールを登録します。

### 実行レイヤー (`mcp-tool.ts`)

検出された各 MCP ツールは、次の処理を行う `DiscoveredMCPTool` インスタンスにラップされます。

- **確認ロジックの処理:** サーバートラスト設定とユーザー設定に基づいて確認ロジックを処理します。
- **ツール実行の管理:** 適切なパラメータで MCP サーバーを呼び出してツール実行を管理します。
- **応答の処理:** LLM コンテキストとユーザー表示の両方の応答を処理します。
- **接続状態の維持:** 接続状態を維持し、タイムアウトを処理します。

### トランスポートメカニズム

Gemini CLI は、次の3つの MCP トランスポートタイプをサポートしています。

- **Stdio トランスポート:** サブプロセスを生成し、stdin/stdout を介して通信します。
- **SSE トランスポート:** Server-Sent Events エンドポイントに接続します。
- **ストリーミング可能な HTTP トランスポート:** 通信に HTTP ストリーミングを使用します。

## MCP サーバーの設定方法

Gemini CLI は、`settings.json` ファイルの `mcpServers` 設定を使用して MCP サーバーを検索し、接続します。この設定は、さまざまなトランスポートメカニズムを持つ複数のサーバーをサポートします。

### settings.json で MCP サーバーを設定する

`~/.gemini/settings.json` ファイルでグローバルレベルで MCP サーバーを設定するか、プロジェクトのルートディレクトリで `.gemini/settings.json` ファイルを作成または開きます。ファイル内に `mcpServers` 設定ブロックを追加します。

### 設定構造

`settings.json` ファイルに `mcpServers` オブジェクトを追加します。

```json
{ ...ファイルには他の設定オブジェクトが含まれています
  "mcpServers": {
    "serverName": {
      "command": "path/to/server",
      "args": ["--arg1", "value1"],
      "env": {
        "API_KEY": "$MY_API_TOKEN"
      },
      "cwd": "./server-directory",
      "timeout": 30000,
      "trust": false
    }
  }
}
```

### 設定プロパティ

各サーバー設定は次のプロパティをサポートしています。

#### 必須 (次のいずれか)

- **`command`** (文字列): Stdio トランスポート用の実行可能ファイルへのパス
- **`url`** (文字列): SSE エンドポイント URL (例: `"http://localhost:8080/sse"`)
- **`httpUrl`** (文字列): HTTP ストリーミングエンドポイント URL

#### オプション

- **`args`** (文字列配列): Stdio トランスポート用のコマンドライン引数
- **`env`** (オブジェクト): サーバープロセスの環境変数。値は `$VAR_NAME` または `${VAR_NAME}` 構文を使用して環境変数を参照できます。
- **`cwd`** (文字列): Stdio トランスポート用の作業ディレクトリ
- **`timeout`** (数値): リクエストのタイムアウト (ミリ秒単位) (デフォルト: 600,000ms = 10 分)
- **`trust`** (ブール値): `true` の場合、このサーバーのすべてのツールコール確認をバイパスします (デフォルト: `false`)

### 設定例

#### Python MCP サーバー (Stdio)

```json
{
  "mcpServers": {
    "pythonTools": {
      "command": "python",
      "args": ["-m", "my_mcp_server", "--port", "8080"],
      "cwd": "./mcp-servers/python",
      "env": {
        "DATABASE_URL": "$DB_CONNECTION_STRING",
        "API_KEY": "${EXTERNAL_API_KEY}"
      },
      "timeout": 15000
    }
  }
}
```

#### Node.js MCP サーバー (Stdio)

```json
{
  "mcpServers": {
    "nodeServer": {
      "command": "node",
      "args": ["dist/server.js", "--verbose"],
      "cwd": "./mcp-servers/node",
      "trust": true
    }
  }
}
```

#### Docker ベースの MCP サーバー

```json
{
  "mcpServers": {
    "dockerizedServer": {
      "command": "docker",
      "args": [
        "run",
        "-i",
        "--rm",
        "-e",
        "API_KEY",
        "-v",
        "${PWD}:/workspace",
        "my-mcp-server:latest"
      ],
      "env": {
        "API_KEY": "$EXTERNAL_SERVICE_TOKEN"
      }
    }
  }
}
```

#### HTTP ベースの MCP サーバー

```json
{
  "mcpServers": {
    "httpServer": {
      "httpUrl": "http://localhost:3000/mcp",
      "timeout": 5000
    }
  }
}
```

## 検出プロセスの詳細

Gemini CLI が起動すると、次の詳細なプロセスを通じて MCP サーバーの検出を実行します。

### 1. サーバーの反復処理と接続

`mcpServers` で設定された各サーバーに対して:

1. **ステータス追跡の開始:** サーバーステータスが `CONNECTING` に設定されます。
2. **トランスポートの選択:** 設定プロパティに基づいて:
   - `httpUrl` → `StreamableHTTPClientTransport`
   - `url` → `SSEClientTransport`
   - `command` → `StdioClientTransport`
3. **接続の確立:** MCP クライアントは設定されたタイムアウトで接続を試みます。
4. **エラー処理:** 接続の失敗はログに記録され、サーバーステータスは `DISCONNECTED` に設定されます。

### 2. ツールの検出

接続に成功すると:

1. **ツールのリスト表示:** クライアントは MCP サーバーのツールリスト表示エンドポイントを呼び出します。
2. **スキーマの検証:** 各ツールの関数宣言が検証されます。
3. **名前のサニタイズ:** Gemini API の要件を満たすようにツール名がクリーンアップされます。
   - 無効な文字 (英数字、アンダースコア、ドット、ハイフン以外) はアンダースコアに置き換えられます。
   - 63 文字を超える名前は中央で置き換えられて切り捨てられます (`___`)。

### 3. 競合の解決

複数のサーバーが同じ名前のツールを公開している場合:

1. **最初の登録が優先:** ツール名を最初に登録したサーバーがプレフィックスなしの名前を取得します。
2. **自動プレフィックス:** 後続のサーバーはプレフィックス付きの名前を取得します: `serverName__toolName`
3. **レジストリ追跡:** ツールレジストリはサーバー名とそのツールの間のマッピングを維持します。

### 4. スキーマ処理

ツールパラメータスキーマは、Gemini API との互換性のためにサニタイズされます。

- **`$schema` プロパティ**は削除されます。
- **`additionalProperties`** は削除されます。
- **`default` を持つ `anyOf`** のデフォルト値は削除されます (Vertex AI の互換性)。
- **再帰的処理**はネストされたスキーマに適用されます。

### 5. 接続管理

検出後:

- **永続的な接続:** ツールを正常に登録したサーバーは接続を維持します。
- **クリーンアップ:** 使用可能なツールを提供しないサーバーの接続は閉じられます。
- **ステータス更新:** 最終的なサーバーステータスは `CONNECTED` または `DISCONNECTED` に設定されます。

## ツール実行フロー

Gemini モデルが MCP ツールの使用を決定すると、次の実行フローが発生します。

### 1. ツールの呼び出し

モデルは次の情報を含む `FunctionCall` を生成します。

- **ツール名:** 登録された名前 (潜在的にプレフィックス付き)
- **引数:** ツールのパラメータスキーマに一致する JSON オブジェクト

### 2. 確認プロセス

各 `DiscoveredMCPTool` は高度な確認ロジックを実装しています。

#### トラストベースのバイパス

```typescript
if (this.trust) {
  return false; // 確認は不要
}
```

#### 動的許可リスト

システムは次の内部許可リストを維持します。

- **サーバーレベル:** `serverName` → このサーバーのすべてのツールが信頼されます。
- **ツールレベル:** `serverName.toolName` → この特定のツールが信頼されます。

#### ユーザー選択の処理

確認が必要な場合、ユーザーは次のいずれかを選択できます。

- **一度だけ続行:** 今回のみ実行します。
- **このツールを常に許可:** ツールレベルの許可リストに追加します。
- **このサーバーを常に許可:** サーバーレベルの許可リストに追加します。
- **キャンセル:** 実行を中止します。

### 3. 実行

確認後 (またはトラストバイパス後):

1. **パラメータの準備:** 引数はツールのスキーマに対して検証されます。
2. **MCP コール:** 基になる `CallableTool` は次の情報でサーバーを呼び出します。

   ```typescript
   const functionCalls = [
     {
       name: this.serverToolName, // 元のサーバーツール名
       args: params,
     },
   ];
   ```

3. **応答処理:** 結果は LLM コンテキストとユーザー表示の両方にフォーマットされます。

### 4. 応答処理

実行結果には次のものが含まれます。

- **`llmContent`:** 言語モデルのコンテキスト用の生の応答部分
- **`returnDisplay`:** ユーザー表示用のフォーマット済み出力 (多くの場合、Markdown コードブロック内の JSON)

## MCP サーバーとの対話方法

### `/mcp` コマンドの使用

`/mcp` コマンドは、MCP サーバーの設定に関する包括的な情報を提供します。

```bash
/mcp
```

これにより、次の情報が表示されます。

- **サーバーリスト:** 設定済みのすべての MCP サーバー
- **接続ステータス:** `CONNECTED`、`CONNECTING`、または `DISCONNECTED`
- **サーバー詳細:** 設定の概要 (機密データを除く)
- **利用可能なツール:** 各サーバーのツールのリストと説明
- **検出状態:** 全体的な検出プロセスのステータス

### `/mcp` 出力の例

```
MCP Servers Status:

📡 pythonTools (CONNECTED)
  Command: python -m my_mcp_server --port 8080
  Working Directory: ./mcp-servers/python
  Timeout: 15000ms
  Tools: calculate_sum, file_analyzer, data_processor

🔌 nodeServer (DISCONNECTED)
  Command: node dist/server.js --verbose
  Error: Connection refused

🐳 dockerizedServer (CONNECTED)
  Command: docker run -i --rm -e API_KEY my-mcp-server:latest
  Tools: docker__deploy, docker__status

Discovery State: COMPLETED
```

### ツールの使用

検出されると、MCP ツールは組み込みツールと同様に Gemini モデルで利用可能になります。モデルは自動的に次の処理を行います。

1. リクエストに基づいて**適切なツールを選択**します。
2. (サーバーが信頼されていない限り) **確認ダイアログを表示**します。
3. 適切なパラメータで**ツールを実行**します。
4. ユーザーフレンドリーな形式で**結果を表示**します。

## ステータス監視とトラブルシューティング

### 接続状態

MCP 統合はいくつかの状態を追跡します。

#### サーバーステータス (`MCPServerStatus`)

- **`DISCONNECTED`:** サーバーが接続されていないか、エラーがあります。
- **`CONNECTING`:** 接続試行中です。
- **`CONNECTED`:** サーバーが接続され、準備ができています。

#### 検出状態 (`MCPDiscoveryState`)

- **`NOT_STARTED`:** 検出は開始されていません。
- **`IN_PROGRESS`:** 現在サーバーを検出中です。
- **`COMPLETED`:** 検出が完了しました (エラーありまたはなし)。

### 一般的な問題と解決策

#### サーバーが接続しない

**症状:** サーバーが `DISCONNECTED` ステータスを示します。

**トラブルシューティング:**

1. **設定の確認:** `command`、`args`、`cwd` が正しいことを確認します。
2. **手動テスト:** サーバーコマンドを直接実行して動作することを確認します。
3. **依存関係の確認:** 必要なすべてのパッケージがインストールされていることを確認します。
4. **ログの確認:** CLI 出力でエラーメッセージを探します。
5. **権限の確認:** CLI がサーバーコマンドを実行できることを確認します。

#### ツールが検出されない

**症状:** サーバーは接続しますが、ツールは利用できません。

**トラブルシューティング:**

1. **ツール登録の確認:** サーバーが実際にツールを登録していることを確認します。
2. **MCP プロトコルの確認:** サーバーが MCP ツールリスト表示を正しく実装していることを確認します。
3. **サーバーログの確認:** サーバー側のエラーについては stderr 出力を確認します。
4. **ツールリスト表示のテスト:** サーバーのツール検出エンドポイントを手動でテストします。

#### ツールが実行されない

**症状:** ツールは検出されますが、実行中に失敗します。

**トラブルシューティング:**

1. **パラメータ検証:** ツールが期待されるパラメータを受け入れることを確認します。
2. **スキーマの互換性:** 入力スキーマが有効な JSON スキーマであることを確認します。
3. **エラー処理:** ツールが未処理の例外をスローしていないか確認します。
4. **タイムアウトの問題:** `timeout` 設定の値を増やすことを検討します。

#### サンドボックスの互換性

**症状:** サンドボックス化が有効になっていると MCP サーバーが失敗します。

**解決策:**

1. **Docker ベースのサーバー:** すべての依存関係を含む Docker コンテナを使用します。
2. **パスのアクセシビリティ:** サーバー実行可能ファイルがサンドボックスで利用可能であることを確認します。
3. **ネットワークアクセス:** 必要なネットワーク接続を許可するようにサンドボックスを設定します。
4. **環境変数:** 必要な環境変数が渡されていることを確認します。

### デバッグのヒント

1. **デバッグモードの有効化:** 詳細な出力を得るには、`--debug_mode` を付けて CLI を実行します。
2. **stderr の確認:** MCP サーバーの stderr がキャプチャされ、ログに記録されます (INFO メッセージはフィルタリングされます)。
3. **分離テスト:** 統合する前に MCP サーバーを個別にテストします。
4. **段階的なセットアップ:** 複雑な機能を追加する前に、単純なツールから始めます。
5. **`/mcp` の頻繁な使用:** 開発中にサーバーステータスを監視します。

## 重要な注意点

### セキュリティに関する考慮事項

- **トラスト設定:** `trust` オプションはすべての確認ダイアログをバイパスします。完全に制御しているサーバーに対してのみ慎重に使用してください。
- **アクセストークン:** API キーまたはトークンを含む環境変数を設定する際は、セキュリティに注意してください。
- **サンドボックスの互換性:** サンドボックス化を使用する場合は、MCP サーバーがサンドボックス環境内で利用可能であることを確認してください。
- **プライベートデータ:** 広範なスコープのパーソナルアクセストークンを使用すると、リポジトリ間で情報が漏洩する可能性があります。

### パフォーマンスとリソース管理

- **接続の永続性:** CLI は、ツールを正常に登録したサーバーへの永続的な接続を維持します。
- **自動クリーンアップ:** ツールを提供しないサーバーへの接続は自動的に閉じられます。
- **タイムアウト管理:** サーバーの応答特性に基づいて適切なタイムアウトを設定します。
- **リソース監視:** MCP サーバーは個別のプロセスとして実行され、システムリソースを消費します。

### スキーマの互換性

- **プロパティの削除:** システムは、Gemini API との互換性のために特定のスキーマプロパティ (`$schema`、`additionalProperties`) を自動的に削除します。
- **名前のサニタイズ:** ツール名は API の要件を満たすように自動的にサニタイズされます。
- **競合の解決:** サーバー間のツール名の競合は、自動プレフィックスによって解決されます。

この包括的な統合により、MCP サーバーは、セキュリティ、信頼性、使いやすさを維持しながら、Gemini CLI の機能を拡張するための強力な方法となります。
