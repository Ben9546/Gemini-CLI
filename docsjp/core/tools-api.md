# Gemini CLI コア: ツール API

Gemini CLI コア (`packages/core`) は、ツールの定義、登録、実行のための堅牢なシステムを備えています。これらのツールは Gemini モデルの機能を拡張し、ローカル環境との対話、Web コンテンツの取得、単純なテキスト生成を超えるさまざまなアクションの実行を可能にします。

## コアコンセプト

- **ツール (`tools.ts`):** すべてのツールのコントラクトを定義するインターフェイスおよびベースクラス (`BaseTool`)。各ツールには次のものが必要です。

  - `name`: 一意の内部名（Gemini への API 呼び出しで使用）。
  - `displayName`: ユーザーフレンドリーな名前。
  - `description`: ツールが何をするかの明確な説明。Gemini モデルに提供されます。
  - `parameterSchema`: ツールが受け入れるパラメータを定義する JSON スキーマ。これは、Gemini モデルがツールを正しく呼び出す方法を理解するために不可欠です。
  - `validateToolParams()`: 受信パラメータを検証するメソッド。
  - `getDescription()`: 実行前に特定のパラメータでツールが何をするかについて、人間が読める形式の説明を提供するメソッド。
  - `shouldConfirmExecute()`: 実行前にユーザーの確認が必要かどうかを判断するメソッド（潜在的に破壊的な操作など）。
  - `execute()`: ツールのアクションを実行し、`ToolResult` を返すコアメソッド。

- **`ToolResult` (`tools.ts`):** ツールの実行結果の構造を定義するインターフェイス。

  - `llmContent`: コンテキストのために LLM に送り返される履歴に含めるための事実に基づいた文字列コンテンツ。
  - `returnDisplay`: CLI で表示するためのユーザーフレンドリーな文字列（多くの場合 Markdown）または特別なオブジェクト（`FileDiff` など）。

- **ツールレジストリ (`tool-registry.ts`):** 次の役割を担うクラス (`ToolRegistry`)。
  - **ツールの登録:** 利用可能なすべての組み込みツール（`ReadFileTool`、`ShellTool` など）のコレクションを保持します。
  - **ツールの検出:** ツールを動的に検出することもできます。
    - **コマンドベースの検出:** `toolDiscoveryCommand` が設定で構成されている場合、このコマンドが実行されます。カスタムツールを記述した JSON を出力することが期待されており、これらは `DiscoveredTool` インスタンスとして登録されます。
    - **MCP ベースの検出:** `mcpServerCommand` が構成されている場合、レジストリはモデルコンテキストプロトコル（MCP）サーバーに接続してツールをリストおよび登録できます (`DiscoveredMCPTool`)。
  - **スキーマの提供:** 登録されているすべてのツールの `FunctionDeclaration` スキーマを Gemini モデルに公開し、利用可能なツールとその使用方法をモデルが認識できるようにします。
  - **ツールの取得:** コアが実行のために名前で特定のツールを取得できるようにします。

## 組み込みツール

コアには、通常 `packages/core/src/tools/` にある、事前定義されたツールスイートが付属しています。これらには次のものが含まれます。

- **ファイルシステムツール:**
  - `LSTool` (`ls.ts`): ディレクトリの内容を一覧表示します。
  - `ReadFileTool` (`read-file.ts`): 単一ファイルの内容を読み取ります。絶対パスである必要がある `absolute_path` パラメータを取ります。
  - `WriteFileTool` (`write-file.ts`): ファイルにコンテンツを書き込みます。
  - `GrepTool` (`grep.ts`): ファイル内のパターンを検索します。
  - `GlobTool` (`glob.ts`): glob パターンに一致するファイルを見つけます。
  - `EditTool` (`edit.ts`): ファイルのインプレース変更を実行します（多くの場合、確認が必要）。
  - `ReadManyFilesTool` (`read-many-files.ts`): 複数のファイルまたは glob パターンからコンテンツを読み取って連結します（CLI の `@` コマンドで使用）。
- **実行ツール:**
  - `ShellTool` (`shell.ts`): 任意のシェルコマンドを実行します（慎重なサンドボックス化とユーザーの確認が必要）。
- **Web ツール:**
  - `WebFetchTool` (`web-fetch.ts`): URL からコンテンツを取得します。
  - `WebSearchTool` (`web-search.ts`): Web 検索を実行します。
- **メモリツール:**
  - `MemoryTool` (`memoryTool.ts`): AI のメモリと対話します。

これらの各ツールは `BaseTool` を拡張し、特定の機能に必要なメソッドを実装します。

## ツール実行フロー

1.  **モデルリクエスト:** Gemini モデルは、ユーザーのプロンプトと提供されたツールのスキーマに基づいて、ツールを使用することを決定し、応答の `FunctionCall` 部分でツール名と引数を指定して返します。
2.  **コアがリクエストを受信:** コアはこの `FunctionCall` を解析します。
3.  **ツールの取得:** `ToolRegistry` で要求されたツールを検索します。
4.  **パラメータ検証:** ツールの `validateToolParams()` メソッドが呼び出されます。
5.  **確認（必要な場合）:**
    - ツールの `shouldConfirmExecute()` メソッドが呼び出されます。
    - 確認の詳細が返された場合、コアはこれを CLI に伝え、CLI はユーザーにプロンプトを表示します。
    - ユーザーの決定（続行、キャンセルなど）がコアに送り返されます。
6.  **実行:** 検証され、確認された場合（または確認が不要な場合）、コアは提供された引数と `AbortSignal`（潜在的なキャンセルのため）を使用してツールの `execute()` メソッドを呼び出します。
7.  **結果処理:** `execute()` からの `ToolResult` がコアによって受信されます。
8.  **モデルへの応答:** `ToolResult` の `llmContent` が `FunctionResponse` としてパッケージ化され、Gemini モデルに送り返され、ユーザー向けの応答の生成を続行できるようにします。
9.  **ユーザーへの表示:** `ToolResult` の `returnDisplay` が CLI に送信され、ツールが何をしたかをユーザーに表示します。

## カスタムツールによる拡張

ユーザーによる新しいツールの直接的なプログラムによる登録は、一般的なエンドユーザー向けの提供ファイルでは主要なワークフローとして明示的に詳述されていませんが、アーキテクチャは次の方法による拡張をサポートしています。

- **コマンドベースの検出:** 上級ユーザーまたはプロジェクト管理者は、`settings.json` で `toolDiscoveryCommand` を定義できます。このコマンドは、Gemini CLI コアによって実行されると、`FunctionDeclaration` オブジェクトの JSON 配列を出力する必要があります。その後、コアはこれらを `DiscoveredTool` インスタンスとして利用可能にします。対応する `toolCallCommand` は、これらのカスタムツールを実際に実行する責任を負います。
- **MCP サーバー:** より複雑なシナリオでは、1 つ以上の MCP サーバーをセットアップし、`settings.json` の `mcpServers` 設定を介して構成できます。その後、Gemini CLI コアは、これらのサーバーによって公開されているツールを検出して使用できます。前述のように、複数の MCP サーバーがある場合、ツール名は設定のサーバー名でプレフィックスが付けられます（例: `serverAlias__actualToolName`）。

このツールシステムは、Gemini モデルの機能を拡張するための柔軟で強力な方法を提供し、Gemini CLI をさまざまなタスクに対応する汎用性の高いアシスタントにします。
